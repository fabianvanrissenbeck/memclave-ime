# In-Memory Enclaves

## Hardware Additions

We add three features to a DPU that aren't present on current editions:
1. CI lockdown - After bootup a DPU does no longer communicate over a CI
   + Already implemented in the Bachelor's project
2. MUX switch - DPUs can explicitly set the MUX state - The host is not
   allowed to switch the MUX anymore
3. Host-ready line - DPUs can poll and lower the ready line, 
   the host can raise it. This is used to ensure synchronized accesses.

## General Kernel Structure

The kernel of the in-memory enclave will be seperated into three
different section with different attributes and levels of trust.
The core/trusted split exists mainly to be able to execute kernels
with a size larger than 24 KiB, therefore requiring some way to
verify code in MRAM.

1. The core section remains on the DPU during its entire lifetime.
2. A trusted section has some specific use-case that requires trust
   and can be seen as an extension to the core section. It is signed
   using the core's key at boot time. The core can therefore verify
   that some code can be part of the trusted section.
3. User code which is assumed to be malicious.

### Core Section

The core section's purpose it to load and verify code generated by a trusted
party before the DPU's boot phase. The core loader is equipped with a
hardcoded key and an implementation for Chacha20-Poly1305. Using this,
the core can verify MAC's generated during the trusted boot process,
including those of trusted sections. Additionally, trusted sections are
allowed to contain secrets, because they can remain encrypted in MRAM.

Requirements for the implementation:

+ Either everything stays in registers and IRAM, or we make sure no other
  threat is running. The first option would be preferable, because it
  assumes less DPU capabilities. Potential oversights due to multiple
  malicious threads cooperating can also be avoided.
+ The implementation must be secured against ROP, because it would allow
  loading malicious code via ROP'ing `ldmai` or extracting the underlying
  key.
+ The register assumption implies a custom Chacha20-Poly1305 implementation
  in UPMEM's assembly language.

## Research

All measurement where made with the compile flag `-Os` and
compiled using UPMEM's most recent (2025.1) SDK.

**Size of Cryptographic Primitives in IRAM**

|                  Primitive                   | Size in IRAM | Percent of IRAM |
|:--------------------------------------------:|-------------:|----------------:|
|               SHA256 (mbedtls)               |   6684 Bytes |           27.20 |
| DHKE (Naive Implementation - 2048 bit group) |   4464 Bytes |           18.16 |